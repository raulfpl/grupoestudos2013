% Revisão de Programação Funcional em Haskell
% Programação Funcional Avançada 
% Prof. Rodrigo Ribeiro

# Revisão --- (I)

- Revisão de Haskell
    - Conceitos: Tipos de dados algébricos e funções de ordem superior.
- Como será feita a revisão:
    - Por meio de um exemplo prático: Codificação de Huffmann.

# Revisão --- (II)

- Codificação de Huffmann.
    - Algoritmo clássico para compressão de texto.
    - Idéia: Atribuir "códigos" curtos para palavras frequentes, 
      reduzindo assim o tamanho do texto.

# Revisão --- (III)

- Estrutura do algoritmo.
    - Compute a frequência de palavras (ou caracteres) do texto.
    - Monte uma árvore de frequências:
        - Primeiramente, cada frequência é uma árvore com somente uma folha.
    - Repita até que haja apenas uma árvore:
        - A partir das duas árvores de menor frequência forme uma nova árvore.

# Revisão --- (IV)

- O que este algoritmo manipula?
    - Palavras --- representadas por strings
    - Frequências --- representadas por inteiros
- Ao invés de usar os tipos \texttt{String} e \texttt{Int}, usaremos
  sinônimos:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.haskell}

    type Word = String
    type Frequency = Int

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- O sinônimo \texttt{Word} é idêntico ao tipo \texttt{String}, porém usar
sinônimos ajuda em tornar o código legível. 
- Mantra: Código = Documentação

# Revisão --- (V)

- Primeiro passo: Cálculo de frequências
    - Divida o texto de entrada em linhas.
    - Na sequência, divida cada linha em palavras.
    - A partir das palavras, monte uma tabela de frequências.
- Como dividir um texto em linhas?
    - Para isso usaremos funções de ordem superior.

# Revisão --- (VI)

- Funções de ordem superior: funções que recebem outras funções como parâmetro.
- Exemplos: map e fold:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.haskell}
    map :: (a -> b) -> [a] -> [b]
    map f [] = []
    map f (x:xs) = f x : map f xs

    foldr :: (a -> b -> b) -> b -> [a] -> b
    foldr f v [] = v
    foldr f v (x:xs) = f x (foldr f v xs)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# Revisão --- (VII)

- Uma possível implementação de \texttt{lines} usa as seguintes funções:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.haskell}
    takeWhile :: (a -> Bool) -> [a] -> [a]
	takeWhile _ []          =  []
	takeWhile p (x:xs) 
            | p x       =  x : takeWhile p xs
            | otherwise =  []    

	dropWhile :: (a -> Bool) -> [a] -> [a]
	dropWhile _ []          =  []
	dropWhile p xs@(x:xs')
            | p x       =  dropWhile p xs'
            | otherwise =  xs            
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- O que cada uma destas funções faz?

# Revisão --- (VIII)

- Com estas funções, podemos dividir o texto em linhas:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.haskell}
    lines :: String -> [String]
    lines [] = []
    lines xs = takeWhile (/='\n') xs : 
    			(lines (dropWhile (/='\n') xs))
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- Porém existe um jeito mais fácil: Existem funções na biblioteca para dividir
texto em linhas e palavras: 

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.haskell}
    lines :: String -> [String]
    words :: String -> [String]
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# Revisão --- (IX)

- Com o texto dividido em uma lista de listas de palavras, basta calcular as frequências.
- Faremos isso utilizando uma tabela de frequências.
    - Cada entrada da tabela possui uma palavra e quantidade de ocorrências dela no texto.
- Utilizaremos a biblioteca de finite maps presente no módulo \texttt{Data.Map}.
- O tipo \texttt{FreqDict} representa finite maps que possuem \texttt{Words} como chaves
  e \texttt{Frequency} como valores.

# Revisão --- (X)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.haskell}
module Dictionary where

import qualified Data.Map as Map

type FreqDict = Map.Map Word Frequency

buildDict :: [Word] -> FreqDict
buildDict = foldr insert emptyDict

insert :: Word -> FreqDict -> FreqDict
insert w dict 
	= case Map.lookup w dict of
	    Nothing -> Map.insert w 1 dict
        Just n  -> Map.insert w (n + 1) dict
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Revisão --- (XI)

- A criação da tabela é feita basicamente por:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.haskell}
    insert :: Word -> FreqDict -> FreqDict
    insert w dict 
	    = case Map.lookup w dict of
	        Nothing -> Map.insert w 1 dict
            Just n  -> Map.insert w (n + 1) dict
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- Caso a palavra atualmente processada já esteja presente 
  na tabela, então incrementa-se a frequência em 1.
- Caso contrário, insere-se esta palavra na tabela com frequência 1.

# Revisão --- (XII)

- Evite usar expressões case sobre tipo de dados Maybe.
- Existe uma função de ordem superior para isso.
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.haskell}
    maybe :: b -> (a -> b) -> Maybe a -> b
    maybe v f Nothing = v
    maybe v f (Just x) = f x
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

- Como representar insert usando esta função?

# Revisão --- (XIII)

- Quase imediato...

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.haskell}
    insert' :: Word -> FreqDict -> FreqDict
    insert' w dict 
        = maybe (Map.insert w 1 dict) 
                (\n -> Map.insert w (n + 1) dict) 
                (Map.lookup w dict)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# Revisão --- (XIV)

- A função:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.haskell}
    Map.lookup :: k -> Map k a -> Maybe a
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
    retorna \texttt{Just v} se \texttt{v} for o valor associado
    a chave \texttt{k} ou \texttt{Nothing}, indicando que a chave
    não está presente no finite map.
- O tipo \texttt{Maybe} é definido como:

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.haskell}
    data Maybe a = Just a | Nothing
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    e é utilizado para representar funções parciais (computações que podem não retornar
    resultados).

- Porquê \texttt{lookup} utiliza o tipo \texttt{Maybe} em seu resultado?

# Revisão --- (XV)

- Com a tabela de frequências construída, como gerar os códigos?
    - Usaremos uma árvore de frequências

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.haskell}
    data Tree = Leaf Word Frequency
          | Node Frequency Tree Tree
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    - Cada nó armazena duas subárvore e a soma das frequências destas.
- Como construir esta árvore?
    - Primeiro geramos uma lista de folhas ordenadas por frequência.
    - Repetidamente retiramos as duas árvores de maior frequências e 
    criamos um nó, inserindo-o novamente na lista. 
    - Repita até possuir uma única árvore.

# Revisão --- (XVI)

- O algoritmo descrito para criar esta árvore parece imperativo...
- É possível transformá-lo em um algoritmo funcional?
    - Sim! Lembre-se: iteração = recursão!
- Primeiro criamos uma lista contendo somente "folhas":

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.haskell}
	leafNodes :: [(Word, Frequency)] -> [Tree]
	leafNodes = map (uncurry Leaf)    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Revisão --- (XVII)

- Gerando nós a partir das folhas

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.haskell}
    glue :: [Tree] -> Tree
    glue [t] = t
    glue ts = glue (glue' ts)
              where
                 glue' (t1:t2:ts) = 
                     insert (join t1 t2) ts
                 join t1 t2 = 
                     Node (value t1 + 
                           value t2) 
                           t1 t2

    makeTree :: [(Word, Frequency)] -> Tree
    makeTree = glue . leafNodes
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Revisão --- (XVIII)

- De posse da árvore de frequências podemos gerar os códigos.
- O algoritmo de geração é bem simples e utiliza um acumulador.
   - Caso a árvore seja uma folha, o código desta é o valor do acumulador.
   - Caso contrário, a sub-árvore esquerda terá código ac ++ [Z] e direita ac ++ [U],
     em que Z e U representam os bits 0 e 1 respectivamente, ac o acumulador atual e
     ++ é a função de concatenação de listas.

# Revisão --- (XIX)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.haskell}
encode :: Tree -> [(Word, [Bit])]
encode t = encode' [] t

encode' cs (Leaf w n) = [(w, cs)]
encode' cs (Node n l r) = (encode' (cs ++ [Z]) l) ++ 
                          (encode' (cs ++ [O]) r)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Revisão --- (XX)

- Com isso terminamos o "aquecimento".
- Código desta aula já está disponível on-line.
- É uma implementação completa de um compressor de textos?
    - Não! Nem por um momento foi citado em como ler o arquivo de entrada
      e como escrever o arquivo comprimido.
    - I/O e outros tipos de efeitos colaterais serão vistos posteriormente
      em maiores detalhes quando falarmos de mônadas.
- Pr\'oxima aula:
    - Veremos como construir testes de unidade para algumas funções
      usando a biblioteca HUnit.