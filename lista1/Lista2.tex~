\documentclass[a4paper,11pt]{exam}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{color}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}


\begin{document}
\topmargin=0pt
\renewcommand{\solutiontitle}{\noident \textbf{Solução:} \par }

\printanswers


% Definindo a exibição dos valores dos pontos.
%\pointpoints{pt}{pts}
%\pointsinmargin
%\pointformat{\framebox[1.8cm]{\themarginpoints $\mid$ \hspace{0.5cm} } }

\vspace{1cm}
%\rhead{  \includegraphics[width=21pt]{ULB.jpg}}
\header{ \includegraphics[width=70pt]{logoicea2.jpg} }
       {\textsc{Universidade Federal de Ouro Preto - icea - decea}\\
        \footnotesize
         Prof.: Elton M. Cardoso\\
         CEA419 - Linguagens de Programação\\
         Lista 1
         \normalsize}
       {\includegraphics[width=25pt]{UfopLogo.jpg} }

\headrule

\vspace{0.2cm}


\textbf{Escrevendo e usando programas em Haskell}
Para a solução desta lista você deve, preferencialmente, criar um módulo para implementar suas soluções. No entanto, 
é possível que as máquinas do laboratório não tenham o compilador instalado. Neste caso, resolva os exercícios apresentados
em papel. Embora seja recomendado que a solução seja feita individualmente, não há restrições quanto a realização da atividade
em grupos de até 2 (dois) alunos \texttt{desde que observada a manutenção de um ambiente sem ruído excessivo} .
 
Para criar um módulo em Haskell faça:
 \begin{itemize}
   \item Use um editor de texto simples. Notepad(Windows), Kate(Linux-KDE) ou GEdit(Linux-GNOME) são suficientes.  
   \item Defina o modulo conforme a sintaxe de Haskell:\\
   \item Salve o arquivo com nome \texttt{Lista3.hs}.
   \item Se estiver em um ambiente Windows\textsuperscript{\textcopyright} e o interpretador de Haskell
    estiver corretamente instalado basta abrir o arquivo do módulo com um duplo click.
    O módulo será automaticamente carregado no interpretador \texttt{GHCi}
   \item Em Linux, abra um prompt de comando, cd para o diretório onde você salvou o módulo, e chame o interpretado com
     o seguinte comando : \texttt{ghci Lista3.hs}
   \item Quando modificar o módulo, recarregue o mesmo com o comando \textbf{\texttt{:r}} no interpretador.
 \end{itemize}

\begin{questions}

  \question Defina a função \texttt{double :: Int ->  Int}, que dado um inteiro, 
  retorna 2 vezes o valor do argumento.
  
  \question Defina a função  \texttt{double2 :: Int -> Int}, usando \texttt{double}, que
  retorna 4 vezes o valor do argumento.
  
  \question Defina a função \texttt{sel :: Bool -> Int -> Int -> Int}, que se comporta do
   seguinte modo: Se o valor do primeiro argumento for \texttt{false}, a função deve retornar o segundo 
   argumento, se o valor do primeiro argumento for \texttt{true}, a função deve retorna o terceiro argumento.\\

  \question Defina a função \texttt{max2 :: Int -> Int -> Int} que retorna o maior entre o dois parâmetros: 
   \begin{itemize}
      \item Usando a função \texttt{sel} do exercício 3.
      \item Sem usar a função \texttt{sel} do exercício 3. 
   \end{itemize}
   
  \question Defina \texttt{max3 :: Int -> Int -> Int -> Int} que retorna o maior entre 3 parâmetros, usando
  \texttt{max2}.

  \question Defina a função \texttt{eq2 :: Int -> Int -> Bool} que retorna \texttt{true} se ambos os argumentos
   são iguais e \texttt{false} caso contrário. \textbf{OBS:} Lembre-se que Haskell \textbf{não} unifica variáveis!

  \question Defina a função  \texttt{diferent3 :: Int -> Int -> Int -> Bool} que retorna \texttt{true} se os 3 argumentos
   forem diferentes, e \texttt{false} caso contrário. 
    
 
  \question  O algoritmo de Euclides pode ser usado para achar o maior divisor comum entre dois números.
  Matematicamente o algoritmo de Euclides pode ser definido do seguinte modo: 
   \begin{center} 
      \begin{tabular}{lcl}
         $gcd(a,0)$ & = & $a$ \\
         $gcd(a,b)$ & = & $gcd(b,a \;mod\; b)$\\
      \end{tabular}
   \end{center}
   Onde $mod$ é a operação que retorna o resto da divisão.\\ 
   \textbf{OBS:} Em Hsakell,  a função \texttt{mod} retorna o resto da divisão do primeiro
   argumento pelo segundo.
   \begin{parts}
      \part Implemente o algoritmo de Euclides em Haskell.
      \part Implemente a função que computa o mínimo múltiplo comum entre dois números, definido como:
\[
      \begin{array}{lcl}
         lcm(a,b) & = &\displaystyle \frac{a\,\cdot\,b}{gcd(a,b)}
      \end{array}
\]  
   \end{parts}
   
  
  \question  A função 91 de McCarthy é definida do seguinte modo:
  \[ 
    m(x)\; = \; \left\{
    \begin{array}{l l}
        n-10 \quad & \text{se $n$ $>$ 100}\\
        m(m(n+11)) \quad & \text{se $n$ $\leq$ 100 }\\
    \end{array} \right.
  \]
  Defina esta função em Haskell. Qual valor esta função retorna para valores de entrada positivos menores que 101 ?
  
  
  \question  Uma fração pode ser representada por pares de valores inteiros, onde o primeiro elemento do par representa
  o numerador e o segundo elemento do par representa o denominador. Por exemplo as seguintes frações
  \begin{center}
     \[\displaystyle \frac{3}{5},\quad  \frac{2}{8} \quad e \quad \frac{3}{4} \]
  \end{center}
  poderiam se expressas em Haskell como :
  \begin{center}
     (3,5), (2,8) e (3,4)
  \end{center}
  Considerado esta representação defina: 
  \begin{parts}
     \part A função \texttt{multf :: (Int,Int) -> (Int,Int) -> (Int,Int)} que multiplica duas frações.\\
      Ex.:\\ 
      GHCi$>$  multf (3,5) (2,8)\\
      (6,40)
     \part A função \texttt{somaf :: (Int,Int) -> (Int,Int) -> (Int,Int)} que soma duas frações.\\
      Ex.:\\ 
      GHCi$>$ somaf (1,2) (1,4)\\
       (6,8)\\
      \part A função \texttt{subf :: (Int,Int) -> (Int,Int) -> (Int,Int)} que subtrai duas frações.\\
      \part A função \texttt{divf :: (Int,Int) -> (Int,Int) -> (Int,Int)} que divide duas frações.\\
      \part A função \texttt{toReal :: (Int,Int) -> Float} que converte a fração em um número real.\\
  \end{parts}
  
  \question  Transforme cada uma das funções recursivas a seguir em recurção de cauda.
   \begin{parts}
     \part \begin{lstlisting}
length :: [a] -> Int
length [] = 0
length (x:xs) = 1 + (length xs) 
           \end{lstlisting}

     \part \begin{lstlisting}
sum :: [Int] -> Int
sum [] = 0
sum (x:xs) = x + (sum xs)             
           \end{lstlisting}

     \part  \begin{lstlisting}
sumLength :: [Int] -> (Int,Int)
sumLength [] = (0,0)
sumLength (x:xs) = (s+x,l+1)
  where (s,l) = sumLength xs            
           \end{lstlisting}
   
   \end{parts}

   \question Defina a função \texttt{intercala :: [Int] -> [Int] -> [Int]} que intercala duas listas de inteiros, 
    do seguinte modo :\\
    GHCi$>$\texttt{intercala [1,2,3] [7,8]}\\
    \texttt{[1,7,2,8,3]}
   
    \question Defina a função \texttt{num2digits :: Int -> [Int]} que transforma um inteiro em uma lista de dígitos correspondente ao número.\\
     Ex.:\\
     GHCi$>$ num2digits 4721\\
     \texttt{[4,7,2,1]}\\
     \textbf{Dica:} Use a função $mod$. 
     
     \question Um número é dito $chic$ se o dígito resultante da soma de seus dígitos ocorre no número. Se o resultado da soma dos 
      dígitos for um número com mais de um dígito, então o processo deve ser repetido até que se obtenha um único dígito.\\
      Ex.:\\
      1276 é $chic$, pois 1+2+7+6 = 16, 1+6 = 7.\\
      123 não é $chic$ , 1+2+3 = 6\\
      Defina a função \texttt{chic :: Int -> Bool} que retorna \texttt{True} se o número for $chic$ e \texttt{False} caso contrário.


      \question Considere a representação de números inteiros positivos como uma lista de dígitos. O número 721, por exemplo, seria
      representado pela lista \texttt{[7,2,1]}.
       \begin{parts}
         \part Defina a função \texttt{soma :: [Int] -> [Int] -> [Int]} que soma dois números inteiros de forma análoga a forma manual 
         de resolver a soma. Por exemplo a soma 781 + 144 seria resolvida:
\begin{lstlisting}
   1
  [7,8,1]
+ [1,4,4]
= [9,2,5]  
\end{lstlisting}
       \texttt{OBS:} É proibido converter o número em inteiro, realizar a operação de soma, e converter o resultado de volta em dígitos.

         \part \texttt{mult :: [Int] -> [Int] -> [Int]} que multiplica dois números inteiros, de forma análoga a forma manual de resolver
         a multiplicação.
       \end{parts}  
 
 \question Defina a função \texttt{breakOn :: Int -> [a] -> ([a],[a])} que divide uma lista em uma dada posição 
  (assuma que primeira posição da lista é a de índice 0). Esta função deve ser feita usando recursão explícita, isto é, você
  não pode utilizar nenhuma outra função para resolver este exercício.\\
  Ex.:\\
  GHCi$>$\texttt{breakOn 3 [0,1,2,3,4]}\\
  \texttt{([0,1,2,3],[4])}  

 \question  Uma função constrói uma lista de inteiros a partir de um argumento inteiro (\texttt{x}) do seguinte modo: 
    \begin{itemize}
      \item O argumento \texttt{x} é inserido na lista.
      \item Se \texttt{x} é par, o novo parâmetro será \texttt{2*x + 1}
      \item Se \texttt{x} é impar, o novo parâmetro será \texttt{div x 2}, onde \texttt{div} é a operação de divisão inteira.  
      \item Se \texttt{x} é zero, a função retorna lista vazia.

    \end{itemize}
    \begin{parts}
       \part  Defina a função descrita.
       \part  A lista produzida pela função é sempre finita ? se não, apresente um valor de entrada
        para o qual a lista não é finita.
       \part  É possível construir uma função \texttt{stop :: [Int] -> Bool} que diz se a lista produzida 
        é finita ou não ? Se sim, apresente a definição desta função.
    \end{parts}
 
 
 
 \question Considere o seguinte tipo de dados algébrico.

\begin{lstlisting}

data Tree a = Tip (Tree a) a (Tree a)
            | Leaf a
     deriving Show
\end{lstlisting}

\begin{parts}
   \part Defina a função \texttt{height :: Tree a -> Int} que computa a altura da árvore.
   \part Defina a função \texttt{flatten :: Tree a -> [a]} que achata a árvore em uma lista.\\
      Ex.: \\
      \texttt{flatten (Tip (Tip (Leaf 2) 1 (Leaf 0)) 5 (Leaf 10) )}\\
      \texttt{[2,1,0,5,10]}\\
   \part Defina a função \texttt{balanced :: Tree a -> Bool} que diz se uma árvore é balanceada ou não.
   \part Defina a função \texttt{heap :: Ord a => [a] -> Tree a} que constrói uma árvore do tipo Heap a partir 
   da lista de entrada.
\end{parts}


\end{questions}


\end{document}
